#!/usr/bin/env ruby
# frozen_string_literal: true

require "fileutils"
require "shellwords"
require "tmpdir"

# ag - tmux agent manager
#
# Manage named panels as windows inside a single tmux session called "ag".
# Every command takes the panel name first.
#
# Module API:
#   Ag.spawn("name")                -> name
#   Ag.shell("name", "cmd")         → runs cmd in panel, streams output back
#   Ag.send_keys("name", "text")    → sends text + Enter
#   Ag.send_raw("name", "C-c")      → sends raw control/byte keys
#   Ag.read("name")                 → captures visible buffer
#   Ag.read("name", full: true)     → captures full scrollback
#   Ag.kill("name")                 → removes panel window
#   Ag.panels                       → { "name" => "name", ... }
#   Ag.attach                       → execs into tmux

SESSION = "ag"

module Ag
  module_function

  ANSI_ESCAPE = /\e\[[\d;?]*[A-Za-z]/.freeze

  # -- tmux primitive --------------------------------------------------------

  def tmux(*args, allow_fail: false)
    out = IO.popen(["tmux", *args.map(&:to_s)], err: [:child, :out], &:read)
    return out if $?.success? || allow_fail
    $stderr.puts "tmux #{args.first}: #{out.strip}"
    exit 1
  end

  def session?
    system("tmux", "has-session", "-t", SESSION, out: File::NULL, err: File::NULL)
  end

  def ensure_session!
    return if session?
    tmux("new-session", "-d", "-s", SESSION, "-n", "shell")
  end

  def target_for(name)
    "#{SESSION}:#{name}"
  end

  def pane_target(name, pane_index = 0)
    "#{target_for(name)}.#{pane_index}"
  end

  # -- panel registry --------------------------------------------------------

  def strip_ansi(text)
    text.gsub(ANSI_ESCAPE, "")
  end

  def tabs
    return [] unless session?
    strip_ansi(tmux("list-windows", "-t", SESSION, "-F", "#W"))
      .lines.map(&:strip).reject(&:empty?)
  end

  def panels
    tabs.each_with_object({}) do |name, out|
      out[name] = name
    end
  end

  def resolve(name)
    panels[name] or abort("unknown panel: #{name}")
  end

  def focus(name)
    resolved = resolve(name)
    tmux("select-window", "-t", target_for(resolved))
    resolved
  end

  # -- core API --------------------------------------------------------------

  def spawn(name)
    return panels[name] if panels[name]

    ensure_session!
    tmux("new-window", "-d", "-t", SESSION, "-n", name)
    name
  end

  # Escape sequences that signal the shell is waiting for input.
  READY_SEQUENCES = [
    "\e[?2004h",  # bracketed paste enable (zsh, bash)
    "\e[?25h",    # show cursor
  ].freeze

  # Optionally capture pane output for `timeout` seconds around a block.
  # Returns early when the output contains a prompt-ready escape and output
  # has settled. Without timeout, fire-and-forget.
  def stream_for(resolved_name, timeout: nil)
    unless timeout
      yield
      return
    end

    dir = Dir.mktmpdir("ag-stream-")
    out_path = File.join(dir, "output")
    FileUtils.touch(out_path)
    target = pane_target(resolved_name)

    tmux("pipe-pane", "-o", "-t", target, "cat >> #{Shellwords.escape(out_path)}")

    yield

    pos = 0
    deadline = Process.clock_gettime(Process::CLOCK_MONOTONIC) + timeout

    File.open(out_path, "rb") do |file|
      loop do
        now = Process.clock_gettime(Process::CLOCK_MONOTONIC)
        break if now >= deadline

        size = File.size(out_path) rescue 0
        if size > pos
          file.seek(pos)
          data = file.read(size - pos)
          if data && !data.empty?
            $stdout.write(data)
            $stdout.flush
            pos += data.bytesize
            # Shell ready signal — clamp deadline so we drain briefly then stop
            if READY_SEQUENCES.any? { |seq| data.include?(seq) }
              cap = now + 0.2
              deadline = cap if cap < deadline
            end
          end
        else
          sleep 0.05
        end
      end
    end

    tmux("pipe-pane", "-t", target) # stop piping
  ensure
    FileUtils.rm_rf(dir) if dir && timeout
  end

  def literal_write(target, text)
    tmux("send-keys", "-t", target, "-l", "--", text)
  end

  def send_keys(name, text, timeout: nil)
    resolved = focus(name)
    target = target_for(resolved)
    stream_for(resolved, timeout: timeout) do
      literal_write(target, text)
      tmux("send-keys", "-t", target, "Enter")
    end
  end

  SPECIAL_KEYS = {
    "Enter" => "Enter",
    "Tab" => "Tab",
    "Esc" => "Escape",
    "BSpace" => "BSpace"
  }.freeze

  def normalize_control(token)
    m = token.match(/\AC-(.)\z/)
    return nil unless m
    "C-#{m[1].upcase}"
  end

  def send_raw(name, *keys, timeout: nil)
    resolved = focus(name)
    target = target_for(resolved)
    stream_for(resolved, timeout: timeout) do
      keys.each do |token|
        key = SPECIAL_KEYS[token] || normalize_control(token)
        if key
          tmux("send-keys", "-t", target, key)
        else
          literal_write(target, token)
        end
      end
    end
  end

  def read(name, full: false)
    resolved = resolve(name)
    target = target_for(resolved)
    args = ["capture-pane", "-p", "-t", target]
    args += ["-S", "-"] if full
    output = tmux(*args)
    lines = output.lines
    lines.pop while lines.last&.strip&.empty?
    lines.empty? ? "" : lines.join
  end

  def kill(name)
    return unless panels[name]
    tmux("kill-window", "-t", target_for(name))
  end

  def kill_all
    tmux("kill-session", "-t", SESSION, allow_fail: true)
  end

  def attach(readonly: true)
    ensure_session!
    spawn("shell") if panels.empty?
    args = ["tmux", "attach-session", "-t", SESSION]
    args << "-r" if readonly
    exec(*args)
  end

  def list
    p = panels
    if p.empty?
      puts "no panels"
    else
      p.each_key { |name| puts "  #{name}" }
    end
  end

  def shell(name, command, timeout: nil)
    abort("missing command") if command.nil? || command.strip.empty?
    ensure_session!

    Dir.mktmpdir("ag-shell-") do |dir|
      out_path = File.join(dir, "output")
      exit_path = File.join(dir, "exit.code")
      FileUtils.touch(out_path)

      wrapped = [
        "bash -lc #{Shellwords.escape(command)}",
        "printf '%s\\n' \"$?\" > #{Shellwords.escape(exit_path)}"
      ].join("; ")

      tmux("kill-window", "-t", target_for(name), allow_fail: true)
      tmux("new-window", "-d", "-t", SESSION, "-n", name, wrapped)
      tmux("pipe-pane", "-o", "-t", pane_target(name),
           "cat >> #{Shellwords.escape(out_path)}")

      pos = 0
      deadline = timeout ? Process.clock_gettime(Process::CLOCK_MONOTONIC) + timeout : nil
      timed_out = false

      File.open(out_path, "rb") do |file|
        loop do
          if deadline && Process.clock_gettime(Process::CLOCK_MONOTONIC) >= deadline
            timed_out = true
            $stderr.puts "\nag: timeout after #{timeout}s"
            tmux("kill-window", "-t", target_for(name), allow_fail: true)
            break
          end

          size = File.size(out_path) rescue 0

          if size > pos
            file.seek(pos)
            data = file.read(size - pos)
            if data && !data.empty?
              $stdout.write(data)
              $stdout.flush
              pos += data.bytesize
            end
            next
          end

          if File.exist?(exit_path)
            # drain remaining output after pipe-pane flushes
            3.times do
              sleep 0.05
              new_size = File.size(out_path) rescue 0
              next unless new_size > pos
              file.seek(pos)
              data = file.read(new_size - pos)
              if data && !data.empty?
                $stdout.write(data)
                $stdout.flush
                pos += data.bytesize
              end
            end
            break
          end

          sleep 0.05
        end
      end

      return 124 if timed_out  # match GNU timeout exit code

      tmux("kill-window", "-t", target_for(name), allow_fail: true)
      Integer(File.read(exit_path).strip)
    end
  end
end

# -- CLI -----------------------------------------------------------------------

HELP = <<~TEXT
  ag - tmux agent manager (session: #{SESSION})

  ag NAME spawn [COMMAND...]  create panel (start here), run command if given
  ag NAME shell COMMAND...    run command, stream output back
  ag NAME send-keys TEXT...   type text + enter into panel
  ag NAME raw   KEY...        send raw keys (eg. C-c, Enter, Esc)
  ag NAME read  [--full]      capture panel buffer
  ag NAME kill                remove panel

  ag list                     show all panels
  ag terminate                destroy tmux session
  ag attach [-rw]              open session (read-only by default)

  Options:
    -tN                        timeout in seconds (default: -t5), exits 124 on timeout

  Start with `spawn` to create a named panel. When in doubt, use `shell`
  — it runs a command and streams output back. For interactive sessions
  (ssh, repls), use spawn + send-keys + read. Add -tN to send-keys/raw
  to stream output until the prompt returns or timeout is hit.
TEXT

# Parse -tN timeout flag from anywhere in ARGV (default: 5s)
TIMEOUT = begin
  idx = ARGV.index { |a| a.match?(/\A-t\d+\z/) }
  idx ? ARGV.delete_at(idx)[2..].to_f : 5.0
end

# Global commands (no panel name required)
case ARGV.first
when "list"
  Ag.list
  exit
when "terminate"
  Ag.kill_all
  puts "session destroyed"
  exit
when "attach"
  rw = ARGV.include?("-rw")
  Ag.attach(readonly: !rw)
  exit
when nil, "-h", "--help", "help"
  $stderr.puts HELP
  exit
end

# Panel commands: ag NAME COMMAND [ARGS...]
name = ARGV.shift
cmd = ARGV.shift

case cmd
when "spawn"
  command = ARGV.join(" ")
  Ag.spawn(name)
  if !command.empty?
    exit Ag.shell(name, command, timeout: TIMEOUT)
  else
    puts "+ #{name}"
  end

when "shell"
  command = ARGV.join(" ")
  abort(HELP) if command.empty?
  exit Ag.shell(name, command, timeout: TIMEOUT)

when "send-keys"
  text = ARGV.join(" ")
  abort(HELP) if text.empty?
  Ag.send_keys(name, text, timeout: TIMEOUT)

when "raw"
  abort(HELP) if ARGV.empty?
  Ag.send_raw(name, *ARGV, timeout: TIMEOUT)

when "read"
  full = ARGV.delete("--full")
  print Ag.read(name, full: !!full)

when "kill"
  Ag.kill(name)
  puts "- #{name}"

else
  $stderr.puts HELP
  exit 1
end
