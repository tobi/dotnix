#!/usr/bin/env ruby
# frozen_string_literal: true

require "digest"
require "fileutils"
require "shellwords"
require "tmpdir"

# ag - tmux agent manager
#
# All named panels live as panes inside a single tiled tmux window.
# State is preserved — every command targeting "foo" goes to the same pane.
#
# Module API:
#   Ag.spawn("name")                -> name
#   Ag.shell("name", "cmd")         → runs cmd in panel, streams output back
#   Ag.send_keys("name", "text")    → sends text + Enter
#   Ag.send_raw("name", "C-c")      → sends raw control/byte keys
#   Ag.read("name")                 → captures visible buffer
#   Ag.read("name", full: true)     → captures full scrollback
#   Ag.kill("name")                 → removes panel pane
#   Ag.panels                       → { "name" => "%id", ... }
#   Ag.watch                        → execs into tmux (read-only)

SESSION = "ag"
WINDOW  = "main"
INIT_TITLE = "_ag_init_"

module Ag
  module_function

  ANSI_ESCAPE = /\e\[[\d;?]*[A-Za-z]/.freeze

  # -- tmux primitive --------------------------------------------------------

  def tmux(*args, allow_fail: false)
    out = IO.popen(["tmux", *args.map(&:to_s)], err: [:child, :out], &:read)
    return out if $?.success? || allow_fail
    $stderr.puts "tmux #{args.first}: #{out.strip}"
    exit 1
  end

  def session?
    system("tmux", "has-session", "-t", SESSION, out: File::NULL, err: File::NULL)
  end

  def ensure_session!
    return if session?
    tmux("new-session", "-d", "-s", SESSION, "-n", WINDOW)
    # Show pane titles on borders
    tmux("set-option", "-t", SESSION, "pane-border-status", "top")
    tmux("set-option", "-t", SESSION, "pane-border-format",
         ' #[bold]#{pane_title} ')
    tmux("set-option", "-t", SESSION, "pane-border-style", "fg=colour240")
    tmux("set-option", "-t", SESSION, "pane-active-border-style", "fg=green,bold")
    tmux("set-option", "-t", SESSION, "pane-border-lines", "heavy")
    # Mark the initial pane so first spawn can reuse it
    id = tmux("list-panes", "-t", "#{SESSION}:#{WINDOW}",
              "-F", '#{pane_id}').lines.first&.strip
    tmux("select-pane", "-t", id, "-T", INIT_TITLE) if id
  end

  # -- panel registry (panes within the single window) ----------------------

  def strip_ansi(text)
    text.gsub(ANSI_ESCAPE, "")
  end

  def pane_map
    return {} unless session?
    result = {}
    tmux("list-panes", "-t", "#{SESSION}:#{WINDOW}",
         "-F", '#{pane_id} #{pane_title}').lines.each do |line|
      line = line.strip
      next if line.empty?
      id, title = line.split(" ", 2)
      result[title.to_s.strip] = id.strip if id
    end
    result
  end

  def find_pane(name)
    pane_map[name]
  end

  def panels
    pm = pane_map
    pm.delete(INIT_TITLE)
    pm
  end

  def resolve(name)
    find_pane(name) or abort("unknown panel: #{name}")
  end

  def focus(name)
    pane_id = resolve(name)
    tmux("select-pane", "-t", pane_id)
    name
  end

  def retile!
    tmux("select-layout", "-t", "#{SESSION}:#{WINDOW}", "tiled")
  end

  # -- pid file: /tmp/ag.pid.<hash> maps pwd → panel name -------------------

  def dir_hash(dir = Dir.pwd)
    Digest::SHA1.hexdigest(dir)[0, 7]
  end

  def pid_path(dir = Dir.pwd)
    "/tmp/ag.pid.#{dir_hash(dir)}"
  end

  def write_pid(name)
    pane_id = find_pane(name)
    return unless pane_id
    # Get the tmux pane pid
    pid = tmux("display-message", "-t", pane_id, "-p", '#{pane_pid}').strip
    File.write(pid_path, "#{name} #{pid} #{pane_id}\n")
  end

  def read_pid
    path = pid_path
    return nil unless File.exist?(path)
    parts = File.read(path).strip.split(" ", 3)
    return nil unless parts.size == 3
    name, pid, pane_id = parts
    # Verify: pane must still exist with the right name and pid
    current_id = find_pane(name)
    return nil unless current_id
    current_pid = tmux("display-message", "-t", current_id, "-p", '#{pane_pid}').strip
    return nil unless current_pid == pid
    name
  end

  def clear_pid(name)
    # Remove any pid files pointing to this panel
    Dir.glob("/tmp/ag.pid.*").each do |path|
      content = File.read(path).strip rescue next
      File.delete(path) if content.start_with?("#{name} ")
    end
  end

  # -- core API --------------------------------------------------------------

  def spawn(name)
    return name if find_pane(name)
    ensure_session!

    init = find_pane(INIT_TITLE)
    if init
      tmux("select-pane", "-t", init, "-T", name)
    else
      pane_id = tmux("split-window", "-d", "-t", "#{SESSION}:#{WINDOW}",
                      "-P", "-F", '#{pane_id}').strip
      tmux("select-pane", "-t", pane_id, "-T", name)
    end
    retile!
    write_pid(name)
    name
  end

  # Escape sequences that signal the shell is waiting for input.
  READY_SEQUENCES = [
    "\e[?2004h",  # bracketed paste enable (zsh, bash)
    "\e[?25h",    # show cursor
  ].freeze

  # Text patterns that signal an interactive prompt waiting for input.
  INTERACTIVE_PROMPT_RE = Regexp.union(
    /(?:password|passphrase|passcode)\s*:\s*$/i,
    /\[y\/n\]\s*:?\s*$/i,
    /\(y\/n\)\s*:?\s*$/i,
    /\[yes\/no\]\s*:?\s*$/i,
    /continue\?\s*\[y\/n\]\s*$/i,
    /press\s+(?:enter|return|any\s+key)/i,
    /enter\s+(?:password|passphrase|pin)\s*:\s*$/i,
  ).freeze

  LOG_DIR = File.join(Dir.home, ".ag", "logs")

  def save_timeout_log(raw_bytes, panel_name, context)
    FileUtils.mkdir_p(LOG_DIR)
    ts = Time.now.strftime("%Y%m%d-%H%M%S")
    path = File.join(LOG_DIR, "#{panel_name}-#{context}-#{ts}.raw")
    File.binwrite(path, raw_bytes)
    $stderr.puts "ag: raw output saved to #{path}"
    $stderr.puts "ag: inspect with: xxd #{path} | less"
  end

  # Capture pane output for `timeout` seconds. Returns early when shell-ready
  # escape sequences or interactive prompts are detected.
  def stream_for(pane_id, timeout: nil, panel_name: nil)
    unless timeout
      yield
      return
    end

    dir = Dir.mktmpdir("ag-stream-")
    out_path = File.join(dir, "output")
    FileUtils.touch(out_path)
    all_data = String.new(encoding: "BINARY")

    tmux("pipe-pane", "-o", "-t", pane_id, "cat >> #{Shellwords.escape(out_path)}")

    yield

    pos = 0
    deadline = Process.clock_gettime(Process::CLOCK_MONOTONIC) + timeout
    timed_out = true

    File.open(out_path, "rb") do |file|
      loop do
        now = Process.clock_gettime(Process::CLOCK_MONOTONIC)
        break if now >= deadline

        size = File.size(out_path) rescue 0
        if size > pos
          file.seek(pos)
          data = file.read(size - pos)
          if data && !data.empty?
            $stdout.write(data)
            $stdout.flush
            pos += data.bytesize
            all_data << data

            if READY_SEQUENCES.any? { |seq| data.include?(seq) }
              timed_out = false
              cap = now + 0.2
              deadline = cap if cap < deadline
            end

            tail = strip_ansi(all_data.byteslice(-512, 512) || all_data)
            if INTERACTIVE_PROMPT_RE.match?(tail)
              timed_out = false
              cap = now + 0.3
              deadline = cap if cap < deadline
            end
          end
        else
          sleep 0.05
        end
      end
    end

    if timed_out && !all_data.empty?
      save_timeout_log(all_data, panel_name || "unknown", "stream")
    end

    tmux("pipe-pane", "-t", pane_id) # stop piping
  ensure
    FileUtils.rm_rf(dir) if dir && timeout
  end

  def send_keys(name, text, timeout: nil)
    pane_id = resolve(name)
    focus(name)
    stream_for(pane_id, timeout: timeout, panel_name: name) do
      tmux("send-keys", "-t", pane_id, "-l", "--", text)
      tmux("send-keys", "-t", pane_id, "Enter")
    end
  end

  SPECIAL_KEYS = {
    "Enter" => "Enter",
    "Tab" => "Tab",
    "Esc" => "Escape",
    "BSpace" => "BSpace"
  }.freeze

  def normalize_control(token)
    m = token.match(/\AC-(.)\z/)
    return nil unless m
    "C-#{m[1].upcase}"
  end

  def send_raw(name, *keys, timeout: nil)
    pane_id = resolve(name)
    focus(name)
    stream_for(pane_id, timeout: timeout, panel_name: name) do
      keys.each do |token|
        key = SPECIAL_KEYS[token] || normalize_control(token)
        if key
          tmux("send-keys", "-t", pane_id, key)
        else
          tmux("send-keys", "-t", pane_id, "-l", "--", token)
        end
      end
    end
  end

  def read(name, full: false)
    pane_id = resolve(name)
    args = ["capture-pane", "-p", "-t", pane_id]
    args += ["-S", "-"] if full
    output = tmux(*args)
    lines = output.lines
    lines.pop while lines.last&.strip&.empty?
    lines.empty? ? "" : lines.join
  end

  def kill(name)
    pane_id = find_pane(name)
    return unless pane_id
    clear_pid(name)
    tmux("kill-pane", "-t", pane_id, allow_fail: true)
    retile! if session?
  end

  def kill_all
    # Clean up all pid files
    Dir.glob("/tmp/ag.pid.*").each { |f| File.delete(f) rescue nil }
    tmux("kill-session", "-t", SESSION, allow_fail: true)
  end

  def watch(readonly: true)
    ensure_session!
    spawn("shell") if panels.empty? && !find_pane(INIT_TITLE)
    args = ["tmux", "attach-session", "-t", SESSION]
    args << "-r" if readonly
    exec(*args)
  end

  def list
    p = panels
    if p.empty?
      puts "no panels"
    else
      p.each { |name, id| puts "  #{name}\t#{id}" }
    end
  end

  def shell(name, command, timeout: nil)
    abort("missing command") if command.nil? || command.strip.empty?
    spawn(name)
    pane_id = resolve(name)

    full_cmd = "#{command}; echo \"\\n\\nEXIT CODE: $?\""

    stream_for(pane_id, timeout: timeout, panel_name: name) do
      tmux("send-keys", "-t", pane_id, "-l", "--", full_cmd)
      tmux("send-keys", "-t", pane_id, "Enter")
    end
  end
end

# -- CLI -----------------------------------------------------------------------

HELP = <<~TEXT
  ag - tmux agent manager (session: #{SESSION})

  All panels are panes in a single tiled window. State is preserved.

  ag NAME spawn [COMMAND...]  create panel (start here), run command if given
  ag NAME shell COMMAND...    run command in panel, stream output back
  ag NAME send-keys TEXT...   type text + enter into panel
  ag NAME raw   KEY...        send raw keys (eg. C-c, Enter, Esc)
  ag NAME read  [--full]      capture panel buffer
  ag NAME kill                remove panel

  NAME is optional for all commands except spawn — if omitted, ag looks up
  the panel previously spawned from the current directory.

  ag list                     show all panels
  ag terminate                destroy tmux session
  ag watch [-rw]              watch session (read-only by default)

  Options:
    -tN                        timeout in seconds (default: -t5), exits 124 on timeout

  Start with `spawn` to create a named panel. When in doubt, use `shell`
  — it runs a command and streams output back. For interactive sessions
  (ssh, repls), use spawn + send-keys + read. Add -tN to send-keys/raw
  to stream output until the prompt returns or timeout is hit.
TEXT

# Parse -tN timeout flag from anywhere in ARGV (default: 5s)
TIMEOUT = begin
  idx = ARGV.index { |a| a.match?(/\A-t\d+\z/) }
  idx ? ARGV.delete_at(idx)[2..].to_f : 5.0
end

# Global commands (no panel name required)
case ARGV.first
when "list"
  Ag.list
  exit
when "terminate"
  Ag.kill_all
  puts "session destroyed"
  exit
when "watch", "attach"
  rw = ARGV.include?("-rw")
  Ag.watch(readonly: !rw)
  exit
when nil, "-h", "--help", "help"
  $stderr.puts HELP
  exit
end

# Panel commands: ag [NAME] COMMAND [ARGS...]
# If first arg is a known command, NAME is omitted — resolve from pwd pid file.
COMMANDS = %w[spawn shell send-keys raw read kill].freeze

first = ARGV.first
if COMMANDS.include?(first)
  # No name given — resolve from pwd
  name = Ag.read_pid
  abort("ag: no panel found for #{Dir.pwd} — spawn one first") unless name || first == "spawn"
  cmd = ARGV.shift
else
  name = ARGV.shift
  cmd = ARGV.shift
end

case cmd
when "spawn"
  abort(HELP) unless name
  command = ARGV.join(" ")
  Ag.spawn(name)
  if !command.empty?
    Ag.shell(name, command, timeout: TIMEOUT)
  else
    puts "+ #{name}"
  end

when "shell"
  command = ARGV.join(" ")
  abort(HELP) if command.empty?
  Ag.shell(name, command, timeout: TIMEOUT)

when "send-keys"
  text = ARGV.join(" ")
  abort(HELP) if text.empty?
  Ag.send_keys(name, text, timeout: TIMEOUT)

when "raw"
  abort(HELP) if ARGV.empty?
  Ag.send_raw(name, *ARGV, timeout: TIMEOUT)

when "read"
  full = ARGV.delete("--full")
  print Ag.read(name, full: !!full)

when "kill"
  Ag.kill(name)
  puts "- #{name}"

else
  $stderr.puts HELP
  exit 1
end
