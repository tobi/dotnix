#!/usr/bin/env ruby
# frozen_string_literal: true

require 'date'
require 'json'
require 'fileutils'

HOSTS_FILE = '/etc/hosts'

# Normalize hostname: strip trailing dots, downcase
def normalize(host)
  host&.chomp('.')&.downcase
end

# Parse /etc/hosts into { hostname => ip }
def parse_hosts_file
  hosts = {}
  File.readlines(HOSTS_FILE).each do |line|
    line = line.strip
    next if line.empty? || line.start_with?('#')

    parts = line.split
    next if parts.length < 2

    ip = parts[0]
    parts[1..].each { |host| hosts[normalize(host)] = ip }
  end
  hosts
end

# Get Tailscale peers as { hostname => ip }
def fetch_tailscale_hosts
  binary = `which tailscale`.strip
  abort 'tailscale not found' if binary.empty?

  status = JSON.parse(`#{binary} status --json`)
  hosts = {}
  tailscale_ips = Set.new

  status['Peer']&.each_value do |peer|
    dnsname = normalize(peer['DNSName'])
    ips = peer['TailscaleIPs']

    next unless dnsname && ips&.any?

    ip = ips.first
    tailscale_ips << ip

    # Extract short hostname from DNSName (e.g., "a6000" from "a6000.tail250b8.ts.net")
    short_name = dnsname.split('.').first

    hosts[short_name] = ip
    hosts[dnsname] = ip
  end

  hosts.delete('localhost')
  [hosts, tailscale_ips]
end

# Reverse { host => ip } to { ip => [hosts] }
def group_by_ip(host_to_ip)
  host_to_ip.each_with_object(Hash.new { |h, k| h[k] = [] }) do |(host, ip), acc|
    acc[ip] << host
  end
end

# Backup and write new hosts file
def write_hosts_file(ip_to_hosts)
  timestamp = DateTime.now.strftime('%Y-%m-%d-%H%M%S')
  backup_path = "/tmp/hosts.old.#{timestamp}"
  FileUtils.cp(HOSTS_FILE, backup_path)

  File.open(HOSTS_FILE, 'w') do |f|
    ip_to_hosts.each do |ip, hosts|
      f.puts "#{ip}\t#{hosts.uniq.sort.join(' ')}"
    end
  end

  backup_path
end

# Flush DNS cache
def flush_dns
  case RUBY_PLATFORM
  when /darwin/
    system('dscacheutil -flushcache')
    system('killall -HUP mDNSResponder')
  when /linux/
    system('resolvectl flush-caches') if system('which resolvectl > /dev/null 2>&1')
  end
end

# Main
begin
  hosts = parse_hosts_file
  tailscale_hosts, tailscale_ips = fetch_tailscale_hosts

  # Remove any existing entries pointing to Tailscale IPs (handles renames)
  hosts.reject! { |_, ip| tailscale_ips.include?(ip) }

  # Merge: tailscale entries added fresh
  hosts.merge!(tailscale_hosts)

  ip_to_hosts = group_by_ip(hosts)
  backup = write_hosts_file(ip_to_hosts)
  flush_dns

  puts "Updated #{HOSTS_FILE} (#{tailscale_hosts.size} tailscale entries)"
  puts "Backup: #{backup}"
rescue => e
  abort "Error: #{e.message}"
end
